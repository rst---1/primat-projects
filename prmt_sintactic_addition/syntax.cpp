/*
 * =====================================================================================
 *
 *       Filename:  syntax.cpp
 *
 *    Description:  edscription of the syntax
 *
 *        Version:  1.0
 *        Created:  01.08.2012 12:39:50
 *       Revision:  none
 *       Compiler:  gcc
 *
 *         Author:  YOUR NAME (), 
 *   Organization:  
 *
 * =====================================================================================
 */
// Так как язык с++ не являеся не естественным английским, не математическим:
x = create_table(); // присвоить иксу (создать таблицу). явно не естественный яз.
create_table(&x); // выполнить функцию create_table и резкьтат присвоить её пара
// метру явно не математически.
// То нужно придерживатся синтаксиса языка С++, но ввиду его гибкости
// установить строгиеправила для читаемости вызова функций.
// Во-первых, функ не должна вызыватся как do_som, тоесть передней должно
// стаять что-то ещё (вообще говоря подлежащее, как в англ языке) и функция
// начинается либо с точки либо с двух двоеточий: .do_som/::do_som. В первом
// случае это объект (экземпляр класса), во-втором либо статический класс либо
// неймспейс (будим называть его Инструментом). Функция это сказуемое, которое
// выполняет подлежащее, функции без точки или четвероточия могут употреблятся
// в случае, если это стандартные библиотеки или если они объявленны в этом же
// файле (хотя и в этом случае можно употреблять четвероточие.), при вызове же
// функции из другого файла префикс обязателен.
// Подлежащее должно быть именем существительным и максимально отражать свою
// сущиность и предназначение. Запись: SomSomSom для интсрумнта и класса,
// и som_som_som для объекта.
// Функция является глаголом (чаще всего), однако функции вида .do (som) излишне
// обобщенны и в коде чаще всего реализуются в виде .do_som (), как частный
// случай, уточнение. Тоесть употребляется с дополнением следующим через
// твёрдый пробел после глагола. Запись: [./::]do_som_som ().
// Употребление падлежащего и сказуемого.
// Бывает несколько вариантов:
tree .grow (); // Дерево расти. Приказ дереву вырасти. Подварианты:
    tree .grow_on_five_millimeters ();
    tree .grow (5);
// если операция возвращает некоторое подтверждение получения результато (а
// лучше чтобы так и было), то записывается так:
report = tree .grow(); // report - стандартный объект вывода сообщений, описан ниже
// более математично если функция что-то возвращает, а не просто выполнчется:
x = GridGenerator ::create_som_grid ();
    x = GridGenerator ::create_som_grid (1, 2);
// Однако, зачастую в с++ функции могут возвращать значения в свои параметры,
// тогда записывается так:
report = GridGenerator ::create_some_grid (goal, with_params 1, 2);
report = GridGenerator ::create_some_grid (1, 2, and_assigned_to doal);
report = GridGenerator ::create_some_grid (assigned_to goal);
// здесь непонятные ключивые слова описываюся так:
#define with_params
#define and_assigned_to
#define assigned_to
// тоесть они ничего не значат и не компилируются, но разъясняют то что делает
// функция без необходимости лезть в документацию с описанием функции.
// Если функция вызывается объектом, то она може не иметь не выходного
// значения, ни входных параметров, так как она прежде всего работает
// с внутренним состоянием объекта. Если же функцию вызывает инструмент, от
// желательней иметь выход, так как инструменты чаще всего не имеют своих
// собственных состояний (внутренее состояние у инструмента - это глобальные
// переменные, объявленные внутри нэймспейса), а использовать чужие
// воспрещается.
 
// ! Не стоит забывать, что "исполняемая строка" в нашем случае - это
// "предложение", которое является полноценным текстом, а не просто строкай
// каманды (чай не питон). Тоесть допускается и крайне рекомендуется перенос
// строк. Не стоит опасантся длинных имен, чем яснее тем лучше (если конечно
// они не приближаются по своей длине к 80 символам).

//Помимо функций (методов) у классов и инструментов бывают поля, обращение
//к ним происходит также как и к методам, но во-первых, пробела между именем
//объекта и его полем не ставится, так как поле не нивое слово а часть общего
//составного, во-вторых, в нём никак не может быть глагола. 
one_obj.two_obj.three_obj;
one_obj::two_obj::three_obj;
// Читается в отличии от связки подлежащее-сказуемое справа на лево (по арабски)
tractor.engine.power;
// Есть особая конструкция "the of_the":
#define the(t, c) (static_cast <t> (c))
#define of
#define of_the
// С помощью неё вырожение выше записывается так:
the (power, of the (engine, of_the tractor));
// или например так:
(the (engine, of_the tractor)).power;
// Так в общемнто более по английски, но для этого ребуется чтобы в классе
// объекта tractor был задан оператор привеления типа к типу объекта engine
// и так далее. Что очевидно непригодно для базовых типов (int, float, bool)
// и в некоторых других случаях.

//! Важно. Глагол всегда является сказуемым и следует только за подлежащим за
//исключением функций из стандартных библиотек и, быть может, локальных
//функций. В то время как поле объекта является существительным, прилогательным
//и пр., но не глаголом.

//Однако, поле может быть функцией (внезапно!) с именнем-не-глаголом. Такая
//функция, например, позволяет полчить значение приватного поля класса. Такие
//поля в основном нужны если инициализируются при создании объекта
//(собственным конструктором или внешним) и существуют неизменными на
//протяжении жизни объекта или если они отражают структуру объекта
//и подчиняются некоторым внутренним законам изменений. В этом случае
//используется функция:
int len () {return p_len;};
// для переменной:
private:
int p_len;

// Также для доступа к полям, разумеется, могут использоватся функции set/get,
// в целях безопасности, например. Они уже являются глаголами со всеми
// вытикающими.

// В качестве сказуемого может выступать слово is, например в таком случае:
this_story .is_true
// Она возвращает значение типа bool, однако подобную запись можно записать
// и по другому:
this_story is true
this_story is not true
this_story is false
// благодоря следующему дефайну 
#define is ==
// и стандартному not. Это кстати тоже важно, крайне желательно вместо
// привычных сишных &&, ||, !, использовать более читабельные end, or, not.

// Про предложения.
// Любое предложение заканчивается точкой с запятой (описания функций это тоже
// предложение и его тоже следует заканчивать точкой с запятой, и пофиг что это
// не обязательно по стандарту!). Так как с++ это не естественный язык, то
// совершенно нормальным тут являются вложенные предложения. Что это за зверь?
// А вот что. Почти все предложения на с++ являются по сути функциями без
// параметров. Так как предложения сдесь имеют повелительное наклонения,
// и заключаются в том что кому то надо что то сделать. Результат этого
// "сделать" по сути и есть выходным результатом этого предложения.
// Исключениями являются описания всего и вся: функций, структу, классов, типов
// и др. А также функциии возвращающие void, но их число лучше сокращать.
// Примером одного из основных предложений является присвоение: 
x = y;
// И оно таки возвращает значение типа bool. Однако это предложение фактически
// является сложным, в большенстве случаев. Если ту x и y - переменные (ну там
// или константы), то это предложение простое и читается как: иксу присвоить
// игрик. Однако, такая халява является редкостью. Фактически оно состоит из
// двух вложанных предложений х и у. В данном случае х и у - это значения
// каторые возвращают стоящие на их местах предложения. Пример:
obj_1.subobj = obj_2 .foo ();
// Такие предложения по стандарту с++ можно запросто запихать в круглые скобки:
((obj_1.subobj) = (obj_2 .foo ()));
// Тут выражение находящееся в скобках фактически является словом в более общем
// выражении. (obj_1.subobj) означает что это одно слово, а не два разных, ()
// после foo показывает, что это пустое слово параметров, (obj_2 .foo ())
// означает что это предложение возвращает результат выполнения функции foo. Ну
// и самын широкие скобки окружают самое крупно предложение, оканчивающееся
// точкой с запятой. Очевидно, что все эти скобки, кроме слова-параметров
// являются необязательными так как расположение в них предложение легко
// распаривается на глаз. Но оно показывает пример употребления скобок,
// и подчинённости предложений. Вот пример, в котором без скобок лучше не
// обходится:
c1.c2 = b1.b2 .set ((a1.a2 .do_som (1, 2)) .do_mos ());
// А так оно записывается со всеми скобками:
((c1.c2) = ((b1.b2) .set (((a1.a2) .do_som (1, 2)) .do_mos ()));
// Сдесь видна иерархия предложений. Читать такое нужно также как
// и арифметические выражения. Тоесть начинается с самого нижнего уровня,
// с самой узкой скобки, и раскрываются понарастающей к самой широкой. Скобки
// же одного уровня раскрываются "паралельно". Тут то и заключается основное
// ограничение на длину предложения, не число символов, число одноуровневых
// скобок и глубина вложения скобок. Чем больше эти два параметра, тем сложнее
// распарсить предложение, компьютер то справится, а мозг и вывихнуть можно.
// Соответственно эти параметры нужно минимизировать. Пока не будим
// конкретезировать максимальные их значения, так как язык с++ весьма гибок
// и позволяет писать крайне разнообразно, да и способности людей к парсингу
// различны. Так что это скорее дело продолжительных эмпирических исследований. 

// А вот пример разложения такого иерархического предложения в более
// читабельный код:
(
 (
  c1.c2
 )
 =
 (
  (
   b1.b2
  )
  .set
  (
   (
    (
     a1.a2
    )
    .do_som
    (
     1, 2
    )
   )
   .do_mos
   (
   )
  )
 )
);
// Тут хорошо видна вся иерархия, все последовательности выполнения
// предложений, гораздо проще парсить. Она конечно преувеличенна, пожно
// подсократить, сохранив читабельность, но она показывает сам принцип как надо
// это делать. Из-за вложенность предложений с++ перенос предложения,
// одладающего глудокой вложенностью, просто по словам, как в обычном тексте
// малоэффективен (текст будит нифига не распознаваемым). Посему перенос
// в таких предложениях лучше осуществлять на основе скобок, составляя блочную
// структуру, как показанно выше. Помимо круглых скобок в с++ есть и другие:
// фигурная и квадратная. Работа с ними выполняется фактически темже образом.

// Помимо блочного разложения предложений, также является хорошим стилем создание 
// переменных хронящих результаты выполнения вложенных предложений. 
{
    B1::B2 b   = b1.b2;
    SomType st = a1.a2 .do_som (1, 2);
    MosType ms = st .do_mos ();
    c1.c2      = b .set (ms);
};
// Или в GNUC:
c1.c2 = ({
           B1::B2 b   = b1.b2;
           SomType st = a1.a2 .do_som (1, 2);
           MosType ms = st .do_mos ();
           b .set (ms);
         });
// Да, в gnu так можно.
// Фигурные скобки нужны вопервых чтобы продемонстрировать, что это всё таки
// одно предлоджение (хотя это не принципиально), а во-вторых, чтобы не плодить
// лишние переменные и не забивать память.
// Низнаю какой из двух стилей лучши и читабельней. В принципе оба неплохи.

// По поводу запятых. Ими можно разделять предложения фактически как и точкой
// с запятой. Но лучше их не использовать, предложения в таком случае
// становятся, с точки зрения неформального языка, сложносочинёнными, а они
// у нас и так иерархические - излишнее переусложнение текста. Запятые
// используются только в отделении параметров функций и заголовке цикла for. 
